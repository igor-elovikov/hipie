#ifndef __ie_vnoise_h
#define __ie_vnoise_h

#include "hash_impl.h"

:: set signature = ["v", "v.x, v.y", "v.x, v.y, v.z", "v.x, v.y, v.z, v.w"]
:: set type = ["float", "float2", "float3", "float4"]
:: set fmod_func = ["fmodr", "fmod2r", "fmod3r", "fmod4r"]
:: set dist_func = ["length", "manhattan_dist", "chebyshev_dist", "minkowski_dist"]
:: set dist_func2 = ["length", "manhattan_dist2", "chebyshev_dist2", "minkowski_dist2"]
:: set func_prefix = ["", "m", "c", "mk"]

// Voronoi Noise

// 2d
:: for period in range(2)
:: for i in range(4)
static void {{"p" if period == 1}}{{ func_prefix[i] }}vnoise2(float seed, float2 pos, float jitter, float* cell_value, 
    float* f1, float* f2, float2* p1, float2* p2{% if period == 1 %},
    int2 period{% endif %}{% if i == 3 %},
    float minkowski_number{% endif %}
    )
{
:: if period == 1
    float2 fperiod = convert_float2(period);
    pos *= fperiod;
:: endif

    float2 id;
    float2 p = fract(pos, &id);

    float F1 = FLT_MAX;
    float F2 = FLT_MAX;
    float cell; 

    float2 pos1, pos2;

    const float2 half_one = (float2)(.5f);
    
    for (int x = -1; x < 2; x++)
    {
        for (int y = -1; y < 2; y++)
        {
            float2 offset = (float2)(x, y);
            float2 hc = id + offset;
:: if period == 1
            float2 h = pzchash_2_2(seed, hc, fperiod) * jitter * .5f + half_one;
:: else
            float2 h = zchash_2_2(seed, hc) * jitter * .5f + half_one;
:: endif
            h += offset;

            float2 d = p - h;
            float dist = {{ dist_func2[i] }}(d{% if i == 3 %}, minkowski_number{% endif %});

            bool pass = dist < F1;
            bool pass2 = dist < F2;

:: if period == 1
            cell = pass ? phash_2_1(seed, hc, fperiod) : cell;                
:: else
            cell = pass ? hash_2_1(seed, hc) : cell;                
:: endif
            F2 = pass2 ? dist : F2;
            F2 = pass ? F1 : F2;
            F1 = pass ? dist : F1;
            pos2 = pass2 ? h + id : pos2;
            pos2 = pass ? pos1 : pos2;
            pos1 = pass ? h + id : pos1;
        }
    }

    (*f1) = F1;
    (*f2) = F2;
    (*p1) = pos1 {{" / fperiod" if period == 1 }};
    (*p2) = pos2 {{" / fperiod" if period == 1 }};
    (*cell_value) = cell;
}

:: endfor
:: endfor

// 3d
:: for period in range(2)
:: for i in range(4)
static void {{"p" if period == 1}}{{ func_prefix[i] }}vnoise3(float seed, float3 pos, float jitter, float* cell_value, 
    float* f1, float* f2, float3* p1, float3* p2{% if period == 1 %},
    int3 period{% endif %}{% if i == 3 %},
    float minkowski_number{% endif %}
    )
{
:: if period == 1
    float3 fperiod = convert_float3(period);
    pos *= fperiod;
:: endif

    float3 id;
    float3 p = fract(pos, &id);

    float F1 = FLT_MAX;
    float F2 = FLT_MAX;
    float cell; 

    float3 pos1, pos2;

    const float3 half_one = (float3)(.5f);
    

    for (int x = -1; x < 2; x++)
    {
        for (int y = -1; y < 2; y++)
        {
            for (int z = -1; z < 2; z++)
            {
                float3 offset = (float3)(x, y, z);
                float3 hc = id + offset;
:: if period == 1
                float3 h = pzchash_3_3(seed, hc, fperiod) * jitter * .5f + half_one;
:: else
                float3 h = zchash_3_3(seed, hc) * jitter * .5f + half_one;
:: endif
                h += offset;

                float3 d = p - h;
                float dist = {{ dist_func[i] }}(d{% if i == 3 %}, minkowski_number{% endif %});

                bool pass = dist < F1;
                bool pass2 = dist < F2;
:: if period == 1
                cell = pass ? phash_3_1(seed, hc, fperiod) : cell;
:: else
                cell = pass ? hash_3_1(seed, hc) : cell;                
:: endif
                F2 = pass2 ? dist : F2;
                F2 = pass ? F1 : F2;
                F1 = pass ? dist : F1;
                pos2 = pass2 ? h + id : pos2;
                pos2 = pass ? pos1 : pos2;
                pos1 = pass ? h + id : pos1;

            }
        }
    }

    (*f1) = F1;
    (*f2) = F2;
    (*p1) = pos1 {{" / fperiod" if period == 1 }};
    (*p2) = pos2 {{" / fperiod" if period == 1 }};
    (*cell_value) = cell;
}

:: endfor
:: endfor

#endif